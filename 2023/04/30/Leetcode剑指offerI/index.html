<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Lemonadeccc"><title>剑指offerI · Lemonadeccc</title><meta name="description" content="剑指offer用两个栈实现队列入栈需要考虑stackA，但是一开始是空数组，一直在插入和删除，不需要考虑大小。
出栈需要考虑stackB，同时stackB的出栈需要依赖stackA的状态。
push进去不需要返回，pop出去需要返回。
12345678910111213141516171819202"><meta name="keywords" content="Blog,博客,Hexo,Lemonadeccc"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Lemonadeccc</a></h3><div class="description"><p>A simple blog</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/Lemonadeccc"><i class="fa fa-github"></i></a></li><li><a href="mailto:zwjhb12@163.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=627636361"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span>  </span><i class="fa fa-star"></i><span> Lemonadeccc</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>剑指offerI</a></h3></div><div class="post-content"><p><h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><p><strong>入栈需要考虑stackA，但是一开始是空数组，一直在插入和删除，不需要考虑大小。</strong></p>
<p><strong>出栈需要考虑stackB，同时stackB的出栈需要依赖stackA的状态。</strong></p>
<p><strong>push进去不需要返回，pop出去需要返回。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var CQueue = function() &#123;</span><br><span class="line">    this.stackA = []</span><br><span class="line">    this.stackB = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * @param &#123;number&#125; value</span><br><span class="line"> * @return &#123;void&#125;</span><br><span class="line"> */</span><br><span class="line">CQueue.prototype.appendTail = function(value) &#123;</span><br><span class="line">    **return** this.stackA.push(value)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">CQueue.prototype.deleteHead = function() &#123;</span><br><span class="line">    if(this.stackB.length) &#123;</span><br><span class="line">        return this.stackB.pop()</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        while(this.stackA.length) &#123;</span><br><span class="line">            this.stackB.push(this.stackA.pop())</span><br><span class="line">        &#125;</span><br><span class="line">        if(!this.stackB.length) &#123;</span><br><span class="line">            return -1</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return this.stackB.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your CQueue object will be instantiated and called as such:</span><br><span class="line"> * var obj = new CQueue()</span><br><span class="line"> * obj.appendTail(value)</span><br><span class="line"> * var param_2 = obj.deleteHead()</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h3 id="30包含min函数的栈"><a href="#30包含min函数的栈" class="headerlink" title="30包含min函数的栈"></a>30包含min函数的栈</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p><strong>用空间换时间，制造了一个minStack和Stack同Push同pop，不过push进去的的时候放入每次放入的最小值。这是时候栈从下到上，依次表示最小值，而且也表示这最小值变换的位置。</strong></p>
<p><strong>Infinity 正无穷大</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var MinStack = function&#123;</span><br><span class="line">	this.stack = [];</span><br><span class="line">	this.minStack = [Infinity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinStack.prototype.push(value)&#123;</span><br><span class="line">	this.stack.push(value);</span><br><span class="line">	this.minStack.push(Math.min(this.minStack[this.minStack.length - 1] , value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinStack.prototype.pop()&#123;</span><br><span class="line">	this.stack.pop()</span><br><span class="line">	this.minStack.pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinStack.prototype.top()&#123;</span><br><span class="line">	return this.stack[this.stack.length - 1]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinStack.prototype.min()&#123;</span><br><span class="line">	return this.minStack[this.minStack.length - 1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="06从尾到头打印链表"><a href="#06从尾到头打印链表" class="headerlink" title="06从尾到头打印链表"></a>06从尾到头打印链表</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>&#x2F;&#x2F;利用了数组把链表的数据放进去，然后调用reverse()方法得到每个节点的值。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var reversePrint = function(head)&#123;</span><br><span class="line">	if(head === null) return []</span><br><span class="line">	const res = []</span><br><span class="line">	while(head)&#123;</span><br><span class="line">		res.push(head)</span><br><span class="line">		 head = head.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return res.reverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;反转链表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function reverseLink(head)&#123;</span><br><span class="line">	if(head === null || head.next === null) return head</span><br><span class="line">	let p = head.next</span><br><span class="line">    head.next = null</span><br><span class="line">    let tmp = null</span><br><span class="line">    while(p !== null)&#123;</span><br><span class="line">    	tmp = p.next</span><br><span class="line">    	p.next = head</span><br><span class="line">    	head = p</span><br><span class="line">    	p = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    return head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24反转链表"><a href="#24反转链表" class="headerlink" title="24反转链表"></a>24反转链表</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点</p>
<p>对于没有的值先赋值，最后两个操作肯定是要复位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var reverseList = funtion(head)&#123;</span><br><span class="line">	let pre = null</span><br><span class="line">	let cur = head;</span><br><span class="line">	while(cur)&#123;</span><br><span class="line">		const tmp = cur.next</span><br><span class="line">		cur.next = pre</span><br><span class="line">		pre = cur</span><br><span class="line">		cur = tmp</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="35复杂链表的复制"><a href="#35复杂链表的复制" class="headerlink" title="35复杂链表的复制"></a>35复杂链表的复制</h3><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<p>使用map记录新节点，然后再来操作、把map中value设置为<code>new Node</code>很新奇，以后记得。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Node(val, next, random) &#123;</span><br><span class="line">   	this.val = val;</span><br><span class="line">	this.next = next;</span><br><span class="line">  	this.random = random;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> var copyRandomList = function(head)&#123;</span><br><span class="line"> 	if(!head) return head</span><br><span class="line"> 	let map = new Map();</span><br><span class="line"> 	let node = head</span><br><span class="line"> 	while(node)&#123;</span><br><span class="line"> 		map.set(node , new Node(node.val))</span><br><span class="line"> 		node = node.next</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	node = head</span><br><span class="line"> 	while(node)&#123;</span><br><span class="line"> 		map.get(node).next = map.get(node.next) !== undefined ? map.get(node.next) : null</span><br><span class="line"> 		map.get(node).random = map.get(node.random)</span><br><span class="line"> 		node = node.next</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return map.get(head)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="05替换空格"><a href="#05替换空格" class="headerlink" title="05替换空格"></a>05替换空格</h3><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p>string split()  join</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//分割</span><br><span class="line">var replaceSpace = funtion()&#123;</span><br><span class="line">	s = s.split(&#x27; &#x27;).join(&#x27;%20&#x27;)</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br><span class="line">//正则</span><br><span class="line">function replaceSpace(s: string): string&#123;</span><br><span class="line">	return s.replace(/\s/g,&#x27;%20&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">//遍历</span><br><span class="line">function replaceSpace(s:string):string&#123;</span><br><span class="line">	let result: string = &quot;&quot;</span><br><span class="line">	for(let i of s)&#123;</span><br><span class="line">		if(i === &quot; &quot;)</span><br><span class="line">			result += &#x27;%20&#x27;</span><br><span class="line">		else</span><br><span class="line">			result += i</span><br><span class="line">	&#125;</span><br><span class="line">	return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="58-II-左旋转字符串"><a href="#58-II-左旋转字符串" class="headerlink" title="58 II 左旋转字符串"></a>58 II 左旋转字符串</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>string返回一个新的字符处啊你，并且不会改动原字符串 [)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var reverseLeftWords = function(s,n)&#123;</span><br><span class="line">	let temp = s.slice(0,n)</span><br><span class="line">	s = s.slice(n.s.length)</span><br><span class="line">	return s + temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="查找（二分-或者-map）"><a href="#查找（二分-或者-map）" class="headerlink" title="查找（二分 或者 map）"></a>查找（二分 或者 map）</h2><h3 id="03数组中重复的数字"><a href="#03数组中重复的数字" class="headerlink" title="03数组中重复的数字"></a>03数组中重复的数字</h3><p>找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>（map）</p>
<p>map[c] &#x3D;&#x3D;&#x3D; undefined也能查找这个数是不是在里面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var findRepeatNumber = function(nums)&#123;</span><br><span class="line">	let map = &#123;&#125;;</span><br><span class="line">	let ans = null;</span><br><span class="line">	for(let i = 0, n = nums.length ; i &lt; n ; i++)&#123;</span><br><span class="line">		let c = nums[i];</span><br><span class="line">		if(map[c] === undefined)&#123;</span><br><span class="line">			map[c] = 1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			ans = c;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="53I在排序数组中查找数字I"><a href="#53I在排序数组中查找数字I" class="headerlink" title="53I在排序数组中查找数字I"></a>53I在排序数组中查找数字I</h3><p>统计一个数字在排序数组中出现的次数。  示例中数组是有序的。</p>
<p>(二分)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var search = function(nums,target)&#123;</span><br><span class="line">	let count = 0,</span><br><span class="line">		n = nums.length,</span><br><span class="line">		left = 0,</span><br><span class="line">		right = n - 1;</span><br><span class="line">		while(left &lt; right)&#123;</span><br><span class="line">			mid = (left + right) &gt;&gt; 1;</span><br><span class="line">			if(nums[mid] === target)&#123;</span><br><span class="line">				left = mid;</span><br><span class="line">				break;</span><br><span class="line">			&#125;else if(nums[mid] &lt; target)&#123;</span><br><span class="line">				left = mid + 1;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				right = mid -1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(nums[left] !== target) return 0;</span><br><span class="line">		let copy = left - 1</span><br><span class="line">		while(copy &gt;= 0 &amp;&amp; nums[copy] === target)&#123;</span><br><span class="line">			copy--;</span><br><span class="line">			count++</span><br><span class="line">		&#125;</span><br><span class="line">		while(left &lt; n &amp;&amp; nums[left] === target)&#123;</span><br><span class="line">			left++;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="53-II-0-n-1中确实的数字"><a href="#53-II-0-n-1中确实的数字" class="headerlink" title="53 II 0~n-1中确实的数字"></a>53 II 0~n-1中确实的数字</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">自己做的，题库没有</span><br><span class="line">var missingNumber = function(nums) &#123;</span><br><span class="line">    for(let i = 0 , n = nums.length; i &lt; n ; i++)&#123;</span><br><span class="line">        if(i !== nums[i])&#123;</span><br><span class="line">            return i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//二分法</span><br><span class="line">var missingNumber = function(nums)&#123;</span><br><span class="line">	let l = 0 , right = nums.length - 1;</span><br><span class="line">	while( l &lt;= r)&#123;</span><br><span class="line">		let m = Math.floor( ( left + right ) / 2);</span><br><span class="line">		if(nums[m] === m)&#123;</span><br><span class="line">			l = m + 1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			r = m - 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04 二维数组中的查找"></a>04 二维数组中的查找</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右 非递减 的顺序排序，每一列都按照从上到下 非递减 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>Array.prototype.flat() 会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//写起来简单，但是复杂度高</span><br><span class="line">var findNumberIn2DArray = function(matrix, target) &#123;</span><br><span class="line">    return matrix.flat(Infinity).includes(target)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//二分</span><br><span class="line">var findNumberIn2DArray = function(martix ,target)&#123;</span><br><span class="line">	for(const item of target)&#123;</span><br><span class="line">		let left = 0,right = item.length - 1;</span><br><span class="line">		while(left &lt;= right)&#123;</span><br><span class="line">			const mid = Math.floor((left + right ) / 2);</span><br><span class="line">			if(item[mid] === target)&#123;</span><br><span class="line">				return true</span><br><span class="line">			&#125;else if(item[mid] &lt; target)&#123;</span><br><span class="line">				left = mid + 1</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				right = mid - 1</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11旋转数组的最小数字"><a href="#11旋转数组的最小数字" class="headerlink" title="11旋转数组的最小数字"></a>11旋转数组的最小数字</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>
<p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  </p>
<p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//投机</span><br><span class="line">var minArray = function(numbers) &#123;</span><br><span class="line">  return Math.min(...numbers)</span><br><span class="line">&#125;;</span><br><span class="line">//二分法</span><br><span class="line">//由于这个有序数组无论处理几次始终是一个环状结构，最小值要么在开头要么在最大值的后一个，当中点的值相等于右指针的值时，由于无法确定最小值在中点的左边还是右边，则直接将右指针左移一位缩小范围，到最后左右指针一定会在最小值的位置相遇</span><br><span class="line">// targrt设置为右那个数。</span><br><span class="line">var  minArray = function(numbers)&#123;</span><br><span class="line">	let l = 0, right = numbers.length - 1;</span><br><span class="line">    while(l &lt; r)&#123;</span><br><span class="line">		let mid = (l + r ) &gt;&gt; 1;</span><br><span class="line">		if(numbers[mid] &lt; numbers[r])&#123;</span><br><span class="line">			r = mid;</span><br><span class="line">		&#125;else if(numbers[mid] &gt; numbers[r])&#123;</span><br><span class="line">			l = mid + 1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			r--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return numbers[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找第一个前者大于后者的数字，若没有则是位置为零的数字</span><br><span class="line">var minArray = function(numbers)&#123;</span><br><span class="line">	for(let i = 0 ; i &lt; numbers.length ; i++)&#123;</span><br><span class="line">		if(numbers[i] &gt; numbers[i + 1])&#123;</span><br><span class="line">			return numbers[i + 1];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return numbers[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="50第一只出现一次的字符"><a href="#50第一只出现一次的字符" class="headerlink" title="50第一只出现一次的字符"></a>50第一只出现一次的字符</h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<p>Array.prototype.indexOf()<strong><code>indexOf()</code></strong> 方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回 -1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indexOf(searchElement, fromIndex)开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回 -1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即 -1 表示从最后一个元素开始查找，-2 表示从倒数第二个元素开始查找，以此类推。注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于 0，则整个数组都将会被查询。其默认值为 0。</span><br></pre></td></tr></table></figure>

<p>利用循环找出第一个数的位置，再次查询这个数位置之后是否还存在相同的数字，存在则继续，不存在则输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var firstUniqChar = function(s)&#123;</span><br><span class="line">	for(let i = 0; i &lt; s.length ; i++)&#123;</span><br><span class="line">		k = s.indexOf(s[i]);</span><br><span class="line">		e = s.indexOf(s[i],k+1);</span><br><span class="line">		if(e == -1) return s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return &quot; &quot;</span><br><span class="line">&#125;</span><br><span class="line">不能吧k = s.indexOf(s[i])去掉，e中的k换为i。</span><br><span class="line">因为，每次都要找相同数的第一个的位置之后才找。不是目前数字的后面一个位置去找。</span><br></pre></td></tr></table></figure>



<h2 id="搜索与回溯算法"><a href="#搜索与回溯算法" class="headerlink" title="搜索与回溯算法"></a>搜索与回溯算法</h2><h3 id="32I-从上到下打印二叉树"><a href="#32I-从上到下打印二叉树" class="headerlink" title="32I 从上到下打印二叉树"></a>32I 从上到下打印二叉树</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>Array.prototype.shift() 会转移并回传队列的<strong>第一个</strong>元素。此方法会改变队列的长度。</p>
<p>**<code>unshift()</code>**方法会增加一个或多个元素至队列的开头，并与回传队列的新长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 按照同一层从左到右的顺序打印，因此使用广度优先遍历，先将同一层的遍历完，再遍历下一层的</span><br><span class="line">// 要实现树的广度优先遍历策略，需要借助队列先进先出的特点，不然每次都还是会做成深度优先，树的左右节点性质就决定了每次会先遍历左节点</span><br><span class="line">var levelOrder = function(root)&#123;</span><br><span class="line">	let res = []</span><br><span class="line">	if(!root)&#123;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">	 // 初始化队列</span><br><span class="line">	let queue = [root];</span><br><span class="line">	// 跳出条件，队列为空，即所有节点都遍历完成</span><br><span class="line">	while(queue.length)&#123;</span><br><span class="line">		// 拿出队首节点</span><br><span class="line">		let node = queue.shift();</span><br><span class="line">		res.push(node.val);				//node.val</span><br><span class="line">		if(node.left)&#123;</span><br><span class="line">			queue.push(node.left);		//queue</span><br><span class="line">		&#125;</span><br><span class="line">		if(node.right)&#123;</span><br><span class="line">			queue.push(node.right);		//queue</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="32-II从上到下打印二叉树II"><a href="#32-II从上到下打印二叉树II" class="headerlink" title="32 II从上到下打印二叉树II"></a>32 II从上到下打印二叉树II</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>运用了一个tmp来进行对某一层的元素的存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var levelOrder = function(root)&#123;</span><br><span class="line">	const res = [];</span><br><span class="line">	if(!root)&#123;</span><br><span class="line">		return res</span><br><span class="line">	&#125;</span><br><span class="line">	let queue = [root];</span><br><span class="line">	while(root.length)&#123;</span><br><span class="line">		let len = queue.length;</span><br><span class="line">		let temp = [];</span><br><span class="line">		for(let i = 0 ; i &lt; len ; i++)&#123;</span><br><span class="line">			let node = queue.shift();</span><br><span class="line">			temp.push(node.val);	//.val</span><br><span class="line">			if(node.left)&#123;</span><br><span class="line">				queue.push(node.left)	//queue</span><br><span class="line">			&#125;</span><br><span class="line">			if(ndoe.right)&#123;</span><br><span class="line">				queue.push(node.right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		res.push(temp)</span><br><span class="line">	&#125;</span><br><span class="line">	return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="32III从上到下打印二叉树III"><a href="#32III从上到下打印二叉树III" class="headerlink" title="32III从上到下打印二叉树III"></a>32III从上到下打印二叉树III</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>采用不同level中对tmp的push()还是unshift()来进行区分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var levelOrder = function(root)&#123;</span><br><span class="line">	let level = 1;</span><br><span class="line">	const res = [];</span><br><span class="line">	const queue = [root];</span><br><span class="line">	while(queue.length)&#123;</span><br><span class="line">		let tmp = [];</span><br><span class="line">		let len = queue.length;</span><br><span class="line">		for(let i = 0 ; i &lt; len ; i++)&#123;</span><br><span class="line">			let node = queue.shift();</span><br><span class="line">			if(level % 2 === 1)&#123;</span><br><span class="line">				tmp.push(node.val);</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				tmp.unshift(node.val);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(node.left) queue.push(node.left)</span><br><span class="line">		if(node.right) queue.push(node.right)</span><br><span class="line">		res.push(tmp);</span><br><span class="line">		level++;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="026-树的子结构"><a href="#026-树的子结构" class="headerlink" title="026 树的子结构"></a>026 树的子结构</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">记录下js解法</span><br><span class="line">判断是不是子树，同时传A.left B.left</span><br><span class="line">如果B是A的子树</span><br><span class="line">要么从A开始 B是子树</span><br><span class="line">要么B是A左子树的子结构</span><br><span class="line">要么B是A右子树的子结构</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; A</span><br><span class="line"> * @param &#123;TreeNode&#125; B</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isSubStructure = function(A, B) &#123;</span><br><span class="line">    if(!B || !A) return false</span><br><span class="line">    return find(A,B) || isSubStructure(A.left, B) || isSubStructure(A.right, B)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function find(A, B)&#123;</span><br><span class="line">    if(!B) return true</span><br><span class="line">    if(!A || A.val != B.val) return false</span><br><span class="line">    return find(A.left,B.left) &amp;&amp; find(A.right, B.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27二叉树的镜像"><a href="#27二叉树的镜像" class="headerlink" title="27二叉树的镜像"></a>27二叉树的镜像</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var mirrorTree = function(root)&#123;</span><br><span class="line">	if(!root) return null;</span><br><span class="line">	[[root.left,root.right]] = [[root.right],[root.left]];</span><br><span class="line">	mirrorTree(root.left);</span><br><span class="line">	mirrorTree(root.right);</span><br><span class="line">	return root</span><br><span class="line">&#125;</span><br><span class="line">//2</span><br><span class="line">var mirrotTree = function(root)&#123;</span><br><span class="line">	if(!root) return null;</span><br><span class="line">	let tmp = root.left;</span><br><span class="line">	root.left = mirrorTree(root.right);</span><br><span class="line">	root.right = mirrorTree(tmp);</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="10-I-斐波那契数列"><a href="#10-I-斐波那契数列" class="headerlink" title="10 I 斐波那契数列"></a>10 I 斐波那契数列</h3><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>
<p>F(0) &#x3D; 0,   F(1) &#x3D; 1<br>F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">var fib = funciton(n)&#123;</span><br><span class="line">	const dp = [0,1];</span><br><span class="line">	for(let i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">		dp[i] = (dp[i-1] + dp[i - 2]) % 1000000007;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[n];</span><br><span class="line">&#125;</span><br><span class="line">//2</span><br><span class="line">var fib = function(n)&#123;</span><br><span class="line">	if(n &lt; 2)&#123;</span><br><span class="line">		return n;</span><br><span class="line">	&#125;</span><br><span class="line">	let p = 0 , q = 0 , r = 1;</span><br><span class="line">	for(let i = 2 ; i &lt;= n; i++)&#123;</span><br><span class="line">		p = q;</span><br><span class="line">		q = r;</span><br><span class="line">		r = (p + q) % 1000000007;</span><br><span class="line">	&#125;</span><br><span class="line">	return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-II-青蛙跳台问题"><a href="#10-II-青蛙跳台问题" class="headerlink" title="10 II 青蛙跳台问题"></a>10 II 青蛙跳台问题</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var numWays = function(n)&#123;</span><br><span class="line">	cosnt dp = [1,1];</span><br><span class="line">	for(let n = 2;i &lt;= n ; i++)&#123;</span><br><span class="line">		dp[i] = (dp[i-1] + dp[i-2]) %1000000007;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="63股票的最大利润"><a href="#63股票的最大利润" class="headerlink" title="63股票的最大利润"></a>63股票的最大利润</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var maxProfit = function(prices)&#123;</span><br><span class="line">	var minCost = prices[0];</span><br><span class="line">	var dp = 0;</span><br><span class="line">	for(var i = 0;i &lt; prices.length ; i++)&#123;</span><br><span class="line">		minCost = Math.min(minCost,prices[i]);</span><br><span class="line">		dp = Math.max(dp,prices[i] - minCost);</span><br><span class="line">	&#125;</span><br><span class="line">	return dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="42连续子数组的最大和"><a href="#42连续子数组的最大和" class="headerlink" title="42连续子数组的最大和"></a>42连续子数组的最大和</h3><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var manSubArray = function(nums)&#123;</span><br><span class="line">	let dp = [nums[0]];</span><br><span class="line">	for(let i = 1 ; i &lt;= nums.length ;  i++)&#123;</span><br><span class="line">		dp[i] = Math.max(nums[i] , dp[i-1] + nums[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return Math.max(...dp);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="47礼物的最大价值"><a href="#47礼物的最大价值" class="headerlink" title="47礼物的最大价值"></a>47礼物的最大价值</h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//只求最后价值所以把原数组破坏了，如果不想就初始化一个新的全是0的dp数组。</span><br><span class="line">var maxValue = function(girid)&#123;</span><br><span class="line">	if(!grid.length) return 0;</span><br><span class="line">	for(let i = 0; i &lt; grid.length ; i++)&#123;</span><br><span class="line">		for(let j = 0; j &lt; grid[0].length ; j++)&#123;</span><br><span class="line">			if(i === 0 &amp;&amp; j === 0) continue;</span><br><span class="line">			if(i === 0) grid[i][j] += grid[i][j - 1];</span><br><span class="line">			if(j === 0) grid[i][j] += grid[i - 1][j];</span><br><span class="line">			if(i !== 0 &amp;&amp; j !== 0) grid[i][j] = Math.max(grid[i - 1][j] , grid[i][j - 1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return grid[grid.length - 1][grid[0].length - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46 把数字翻译成字符串"></a>46 把数字翻译成字符串</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p>​    数字每每一位或者两位判断，转换成字符串，然后进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var translateNum = function(num)&#123;</span><br><span class="line">	if(num &lt; 10) return 1;</span><br><span class="line">	let str = num + &#x27;&#x27;;</span><br><span class="line">	let dp = [1,1];</span><br><span class="line">	for(let i = 1 ; i &lt; str.length ; i++)&#123;</span><br><span class="line">		let tmp = parseInt(str.slice(i - 1 , i + 1) , 10) || 0;</span><br><span class="line">		if(tmp &gt;= 10 &amp;&amp; tmp &lt;= 25)&#123;</span><br><span class="line">			dp[i + 1] = dp[i] + dp[i -1];</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			dp[i + 1] = dp[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[dp.length - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="48最长不含重复字符的子字符串"><a href="#48最长不含重复字符的子字符串" class="headerlink" title="48最长不含重复字符的子字符串"></a>48最长不含重复字符的子字符串</h3><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p>​    该**<code>lastIndexOf()</code>**方法给定一个参数：要搜索的子字符串，搜索整个调用字符串，并返回指定子字符串最后一次出现的索引。给定第二个参数：一个数字，该方法返回指定子字符串在小于或等于指定数字的索引处的最后一次出现。</p>
<p>  关于字符串的不重复字符串，需要不重复字符串的首位索引，本题最后只要求字符串的长度，所以直接pop。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class="line">    if(!s.length) return 0;</span><br><span class="line">    let dp = [1];</span><br><span class="line">    for(let i=0,j=1;j&lt;s.length;j++)&#123;</span><br><span class="line">        let k = s.slice(0,j).lastIndexOf(s[j]);</span><br><span class="line">        if(k &lt; i)&#123;</span><br><span class="line">            dp[j] = dp[j-1] &gt; j-i+1 ? dp[j-1] :j-i+1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            i = k + 1;</span><br><span class="line">            dp[j] = dp[j-1] &gt; j-i+1 ? dp[j-1] :j-i+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp.pop();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="18删除链表的节点"><a href="#18删除链表的节点" class="headerlink" title="18删除链表的节点"></a>18删除链表的节点</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p><strong>注意：</strong>此题对比原题有改动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function ListNode(val)&#123;</span><br><span class="line">	this.val = val;</span><br><span class="line">	this.next = null;</span><br><span class="line">&#125;</span><br><span class="line">var deleteNode = function(head,val)&#123;</span><br><span class="line">	if(!head) return head;</span><br><span class="line">	let dummy = new ListNode(0);</span><br><span class="line">	dummy.next = head;</span><br><span class="line">	let cur = dummy;</span><br><span class="line">	while(cur &amp;&amp; cur.next)&#123;</span><br><span class="line">		cur.next.val === val ? cur.next = cur.next.next : cur = cur.next</span><br><span class="line">	&#125;</span><br><span class="line">	return dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22 链表中倒数第k个节点"></a>22 链表中倒数第k个节点</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var getKthFromEnd = function(head,k)&#123;</span><br><span class="line">	let fast = head;</span><br><span class="line">	let slow = head;</span><br><span class="line">	let flag = 0;</span><br><span class="line">	while(fast)&#123;</span><br><span class="line">		if(flag &gt;= k) slow = slow.next;</span><br><span class="line">		fast = fast.next;</span><br><span class="line">		flag++;</span><br><span class="line">	&#125;</span><br><span class="line">	return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25合并两个排序的链表"><a href="#25合并两个排序的链表" class="headerlink" title="25合并两个排序的链表"></a>25合并两个排序的链表</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//普通方法</span><br><span class="line">var mergeTwoLists = function(l1,l2)&#123;</span><br><span class="line">	let newList = new ListNode(-1);</span><br><span class="line">	let currNode = nweList;</span><br><span class="line">	while(l1 &amp;&amp; l2)&#123;</span><br><span class="line">		if(l1.val &lt; l2.val)&#123;</span><br><span class="line">			currNode.next = l1;</span><br><span class="line">			l1 = l1.next;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			currNode.next = l2;</span><br><span class="line">			l2 = l2.next;</span><br><span class="line">		&#125;</span><br><span class="line">		currNode = currNode.next;</span><br><span class="line">	&#125;</span><br><span class="line">	currNode.next = l1 || l2;				注意这里是两道杠</span><br><span class="line">	return newList.next;</span><br><span class="line">&#125;</span><br><span class="line">//递归</span><br><span class="line">var mergeTwoLists = function(l1,l2)&#123;</span><br><span class="line">	if(!l1) return l2;</span><br><span class="line">	if(!l2) return l1;</span><br><span class="line">	if(l1.val &lt;= l2.val)&#123;</span><br><span class="line">		l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">		return l1;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">		return l2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//迭代</span><br><span class="line">function mergeTwoLists = function(l1,l2)&#123;</span><br><span class="line">	let result : listNode = new ListNode(-1);</span><br><span class="line">	let temp : listNode=  result;</span><br><span class="line">	while(l1 &amp;&amp; l2)&#123;</span><br><span class="line">		if(l1.val &lt;= l2.val)&#123;</span><br><span class="line">			temp.next =  l1;</span><br><span class="line">			l1 = l1.next;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			temp.next = l2;</span><br><span class="line">			l2 = l2.next;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	temp.next = l1 || l2;</span><br><span class="line">	return result.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="052两个链表的第一个公共节点"><a href="#052两个链表的第一个公共节点" class="headerlink" title="052两个链表的第一个公共节点"></a>052两个链表的第一个公共节点</h3><p>输入两个链表，找出它们的第一个公共节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//A前 + 公共 + B前  =  B前 + 公共 + A前</span><br><span class="line">var getIntersectionNode = function(headA,headB)&#123;</span><br><span class="line">	let tempA = headA,tempB = headB;</span><br><span class="line">	while(tempA !== tempB)&#123;</span><br><span class="line">		tempA = tempA ? tempA.next : headB;</span><br><span class="line">		tempB = tempB ? tempB.next : headA;</span><br><span class="line">	&#125;</span><br><span class="line">	return tempA;</span><br><span class="line">&#125;</span><br><span class="line">//笨法，双指针，计算两条链表长度，遍历长的链表与短的链表的头结点是否相同。相同则停止；不同指导长链表长度与短链表长度相同，则长链表与短链表同时遍历并比较</span><br><span class="line">var getIntersectionNode = function(headA,headB)&#123;</span><br><span class="line">	if(headA || headB) return null;</span><br><span class="line">	var A = headA;</span><br><span class="line">	var ALength = 0;</span><br><span class="line">	var B = headB;</span><br><span class="line">	var BLength = 0;</span><br><span class="line">	while(A)&#123;</span><br><span class="line">		ALength++;</span><br><span class="line">		A = A.next;</span><br><span class="line">	&#125;</span><br><span class="line">	A = headA;</span><br><span class="line">	while(B)&#123;</span><br><span class="line">		BLength++;</span><br><span class="line">		B = B.next;</span><br><span class="line">	&#125;</span><br><span class="line">	B = headB;</span><br><span class="line">	if(ALength &lt;= BLenght)&#123;</span><br><span class="line">		A = headB;</span><br><span class="line">		B = headA;</span><br><span class="line">		[ALength,BLenght] = [BLength,ALength];</span><br><span class="line">	&#125;</span><br><span class="line">	while(A)&#123;</span><br><span class="line">		if(A === B) return A;</span><br><span class="line">		A = A.next;</span><br><span class="line">		if(ALength &lt;= BLength) B = B.next;</span><br><span class="line">		ALength -= 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21调整数组顺序使奇数位于偶数前面"><a href="#21调整数组顺序使奇数位于偶数前面" class="headerlink" title="21调整数组顺序使奇数位于偶数前面"></a>21调整数组顺序使奇数位于偶数前面</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//双指针：头尾遍历</span><br><span class="line">var exchange  = function(array)&#123;</span><br><span class="line">	let start = 0,end = array.length - 1;</span><br><span class="line">	while(start &lt; end)&#123;</span><br><span class="line">		while(array[start] % 2 === 1) start++;</span><br><span class="line">		while(array[end] % 2 === 0 ) end--;</span><br><span class="line">		if(start &lt; end) [array[start],array[end]] = [array[end],array[start]];</span><br><span class="line">	&#125;</span><br><span class="line">	return array;</span><br><span class="line">&#125;</span><br><span class="line">//双指针:两个指针同时从第一个元素触发。s1找偶数，s2找奇数。偶在奇前面就交换位置。否则偶数不动，不交换，继续找后面的奇数</span><br><span class="line">var exchange = function(array)&#123;</span><br><span class="line">	let s1 = 0, s2 = 0;</span><br><span class="line">	const len = array.length - 1;</span><br><span class="line">	while(s2 &lt;= len &amp;&amp; s1 &lt;= len)&#123;</span><br><span class="line">		while(array[s1] % 2 === 1) s1++;</span><br><span class="line">		while(array[s2] % 2 === 0) s2++;</span><br><span class="line">		if(s1 &lt; s2)&#123;</span><br><span class="line">			if(s2 &lt;= len &amp;&amp; s1 &lt;= len)&#123;</span><br><span class="line">				[array[s1] , array[s2]] = [array[s2],array[s1]]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			s2++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="057-和为s的两个数字"><a href="#057-和为s的两个数字" class="headerlink" title="057 和为s的两个数字"></a>057 和为s的两个数字</h3><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//双指针</span><br><span class="line">var twoSum = function(nums,target)&#123;</span><br><span class="line">	let left = 0 , right = nums.length - 1;</span><br><span class="line">	let sum = 0;</span><br><span class="line">	while(left &lt; right)&#123;</span><br><span class="line">		sum = nums[left] + nums[right];</span><br><span class="line">		if(sum &lt; targht)&#123;</span><br><span class="line">			left++;</span><br><span class="line">		&#125;else if(sum &gt; target)&#123;</span><br><span class="line">			right--;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return [nums[left],nums[right]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return []</span><br><span class="line">&#125;</span><br><span class="line">//哈希表</span><br><span class="line">function twoSum(nums: number[], target: number):number[]&#123;</span><br><span class="line">	const map: Map&lt;number,number&gt; = new Map();</span><br><span class="line">	for(let i of nums)&#123;</span><br><span class="line">        if(!map.has(i))</span><br><span class="line">            map.set(target - i);</span><br><span class="line">        else</span><br><span class="line">            return [i,map.get[i]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="058反转单词顺序"><a href="#058反转单词顺序" class="headerlink" title="058反转单词顺序"></a>058反转单词顺序</h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var reverseWords = function(s)&#123;</span><br><span class="line">	let arr = s.trim().replace(/s+/g,&#x27; &#x27;).split(&#x27; &#x27;)</span><br><span class="line">	let left = 0 , right = arr.length - 1;</span><br><span class="line">	while(left &lt; right)&#123;</span><br><span class="line">		[arr[left],arr[right]] = [[arr.right],[arr.left]];</span><br><span class="line">		left++;</span><br><span class="line">		right--;</span><br><span class="line">	&#125;</span><br><span class="line">	return arr.join(&#x27; &#x27;)</span><br><span class="line">&#125;</span><br><span class="line">//或者</span><br><span class="line">var reverseWords = function(s : string) : string&#123;</span><br><span class="line">	return s.trim().split(/s+/g).reverse().join(&quot; &quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搜索与回溯算法（中等）"><a href="#搜索与回溯算法（中等）" class="headerlink" title="搜索与回溯算法（中等）"></a>搜索与回溯算法（中等）</h2><h3 id="12矩阵中的路径"><a href="#12矩阵中的路径" class="headerlink" title="12矩阵中的路径"></a>12矩阵中的路径</h3><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var exist = function(board,word)&#123;</span><br><span class="line">	for(let i = 0; i &lt; board.length ; i++)&#123;</span><br><span class="line">		for(let j = 0 ; j &lt; board[0].length ; j++)&#123;</span><br><span class="line">			if(dfs(board,word,i,j,0)) return true;		//忘了if的条件</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	retrun false;</span><br><span class="line">	function dfs(board,word,i,j,k)&#123;</span><br><span class="line">			//递归的base case</span><br><span class="line">		if(i &lt; 0 || j &lt; 0 || i &gt;= board.length || j &gt;= board[0].length || board[i][j] !== word[k])&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		if(k === word.length - 1)&#123;</span><br><span class="line">			console.log(&#x27;k&#x27;,k);</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		board[i][j] = &#x27;&#x27;;	//标记  ，别忘了[j]</span><br><span class="line">		let res = dfs(board,word,i-1,j,k+1) || dfs(board,word,i+1,j,k+1) || dfs(board,word,i,j-1,k+1) || dfs(board,word,i,j+1,k+1);</span><br><span class="line">		board[i][j] = word[k];</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13机器人的运动范围"><a href="#13机器人的运动范围" class="headerlink" title="13机器人的运动范围"></a>13机器人的运动范围</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//BFS</span><br><span class="line">var movingCount = function(m,n,k)&#123;</span><br><span class="line">	const arr = new Array(m).fill().map(_ =&gt; new Array(n).fill(0));</span><br><span class="line">	const queue = [[0,0]];		//注意初始的是[0,0]</span><br><span class="line">	let counter = 0;</span><br><span class="line">	while(queue.length)&#123;</span><br><span class="line">		const [x,y] = queue.shift()</span><br><span class="line">		if(x &gt;= m || y&gt;= n ) continue;</span><br><span class="line">		if(arr[x][y]) continue;</span><br><span class="line">		arr[x][y] = 1;</span><br><span class="line">		</span><br><span class="line">		if(bitSum(x) + bitSum(y) &lt;= k)&#123;</span><br><span class="line">			counter++;</span><br><span class="line">			queue.push([x+1,y],[x,y+1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return counter;</span><br><span class="line">	function bitSum(n)&#123;</span><br><span class="line">		let res = 0;</span><br><span class="line">		while(n)&#123;</span><br><span class="line">			res += n % 10;</span><br><span class="line">			n =  Math.floor(n / 10);</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//DFS</span><br><span class="line">var movingCount = function(m,n,k)&#123;</span><br><span class="line">	const arr = new Array(m).fill().map(_ =&gt; new Array(m).fill(0));</span><br><span class="line">	let counter = 0;</span><br><span class="line">	run(0,0);</span><br><span class="line">	return counter;</span><br><span class="line">	</span><br><span class="line">	funciton run(i,j)&#123;</span><br><span class="line">		if(i &gt;= m || j &gt;= n ) return;</span><br><span class="line">		if(arr[i][j]) return </span><br><span class="line">		arr[i][j] = 1;</span><br><span class="line">		if(bitSum(i) + bitSum(j) &lt;= k)&#123;</span><br><span class="line">			counter++;</span><br><span class="line">			run(i+1,j);</span><br><span class="line">			run(i,j+1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	function bitSum(n)&#123;</span><br><span class="line">		let res = 0;</span><br><span class="line">		while(n)&#123;</span><br><span class="line">			res += n % 10;</span><br><span class="line">			n = Math.floor(n / 10);</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="34二叉树中和维某一值的路径"><a href="#34二叉树中和维某一值的路径" class="headerlink" title="34二叉树中和维某一值的路径"></a>34二叉树中和维某一值的路径</h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var pathSum = function(root,target)&#123;</span><br><span class="line">	let res = [];</span><br><span class="line">	function pathTree(root,target,path)&#123;</span><br><span class="line">		if(!root) return </span><br><span class="line">		if(!root.left &amp; !root.right &amp;&amp; target === root.val)&#123;</span><br><span class="line">			path.push(root.val);</span><br><span class="line">			res.push(path.slice());</span><br><span class="line">		&#125;</span><br><span class="line">		path.push(root.val);</span><br><span class="line">		pathTree(root.left,target - root.val,path.slice());</span><br><span class="line">		pathTree(root.right,target - root.val,path.slice());</span><br><span class="line">		path.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	pathTree(root,target,[]);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="36二叉搜索树与双向链表"><a href="#36二叉搜索树与双向链表" class="headerlink" title="36二叉搜索树与双向链表"></a>36二叉搜索树与双向链表</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var treeToDoublyList = funciton(root)&#123;</span><br><span class="line">	function dfs(root)&#123;</span><br><span class="line">		if(!root) return root;</span><br><span class="line">		dfs(root.left);</span><br><span class="line">		pre ? pre.right = root : head = root;</span><br><span class="line">		root.left = pre;</span><br><span class="line">		pre = root;</span><br><span class="line">		dfs(root.right);</span><br><span class="line">	&#125;</span><br><span class="line">	let pre = null, head = null;</span><br><span class="line">	if(!root) return root;</span><br><span class="line">	dfs(root);</span><br><span class="line">	head.left = pre;</span><br><span class="line">	pre.right = head;</span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="54二叉搜索树的第k大节点"><a href="#54二叉搜索树的第k大节点" class="headerlink" title="54二叉搜索树的第k大节点"></a>54二叉搜索树的第k大节点</h3><p>给定一颗二叉搜索树，请找出其中第k大的节点的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var kehLargest = function(root,k)&#123;</span><br><span class="line">	let res = [];</span><br><span class="line">	treeToSortedArr(root,res);</span><br><span class="line">	return res[k-1];</span><br><span class="line">	</span><br><span class="line">	function treeToSortedArr(root,res)&#123;</span><br><span class="line">		if(!root) return;</span><br><span class="line">		treeToSortedArr(root.right,res);</span><br><span class="line">		res.push(root.val);</span><br><span class="line">		treeToSortedArr(root.left,,res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="45把数组排成最小的数"><a href="#45把数组排成最小的数" class="headerlink" title="45把数组排成最小的数"></a>45把数组排成最小的数</h3><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var minNumber = function(nums)&#123;</span><br><span class="line">	return minNums = nums.sort( (a,b) =&gt; &#123;</span><br><span class="line">		return Number(String(a) + b) - Number(String(b) + a)</span><br><span class="line">	&#125;).join(&#x27;&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="61扑克牌中的顺子"><a href="#61扑克牌中的顺子" class="headerlink" title="61扑克牌中的顺子"></a>61扑克牌中的顺子</h3><p>从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//常规方法， 相邻两个的差 和 0 的情况</span><br><span class="line">var isStraight = function(nums)&#123;</span><br><span class="line">	nums.sort( (a,b) =&gt; &#123;return a - b&#125;);</span><br><span class="line">	let zeroN = nums.lastIndexOf(0) + 1;</span><br><span class="line">	let c = 0;</span><br><span class="line">	for(let i = 0 ; i &lt; resetArr.length - 1 ; i++)&#123;</span><br><span class="line">		if(resetArr[i] + 1 &lt; resetArr[i + 1])&#123;</span><br><span class="line">			c += resetArr[i+1] - resetArr[i] - 1;</span><br><span class="line">		&#125;else if(resetArr[i+1] === resetArr[i])&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return c &lt;= zeroN;</span><br><span class="line">&#125;</span><br><span class="line">//用set，除了0不能有其他重复的牌，除0以外五张牌中最大的牌和最小的牌相差&lt;=5</span><br><span class="line">var isStraight = function(nums)&#123;</span><br><span class="line">	const set = new Set();</span><br><span class="line">	let max = 0,min = 14;</span><br><span class="line">	for(let item of nums)&#123;</span><br><span class="line">		if(item) continue;</span><br><span class="line">		if(set.has(item)) return false;</span><br><span class="line">		max = Math.max(item,max);</span><br><span class="line">		min = Math.min(item,min);</span><br><span class="line">		set.add(item);</span><br><span class="line">	&#125;</span><br><span class="line">	return max - min &lt; 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="40最小的k个数"><a href="#40最小的k个数" class="headerlink" title="40最小的k个数"></a>40最小的k个数</h3><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//最简单</span><br><span class="line">var getLeastNumber = function(arr,k)&#123;</span><br><span class="line">	return arr.sort( (a,b) =&gt; return a - b).slice(0,k);</span><br><span class="line">&#125;</span><br><span class="line">//快排</span><br><span class="line">var getLeastNumber = function(arr,k)&#123;</span><br><span class="line">	qSort(arr,0,arr.length - 1);</span><br><span class="line">	return arr.slice(0,k);</span><br><span class="line">	</span><br><span class="line">	fucntion qSort(arr,low,high)&#123;</span><br><span class="line">		if(low &gt;= high) return</span><br><span class="line">		let flag = arr[low];</span><br><span class="line">         let left = low,right = high;</span><br><span class="line">         while(left &lt; right)&#123;</span><br><span class="line">         	while(arr[right] &gt;= flag &amp;&amp; left &lt; right) right--;</span><br><span class="line">         	while(arr[left] &lt;= flag &amp;&amp; left &lt; right) left++;</span><br><span class="line">         	if(left &lt; right)&#123;</span><br><span class="line">         		let temp = arr[left];</span><br><span class="line">         		arr[left] = arr[right];</span><br><span class="line">         		arr[right] = temp;</span><br><span class="line">         	&#125;</span><br><span class="line">         &#125;</span><br><span class="line">         arr[low] = arr[right];</span><br><span class="line">         arr[right] = flag;</span><br><span class="line">         if(right === k) return </span><br><span class="line">         k &lt; right ? qSort(arr,low,right - 1) : qSort(arr,right + 1,high);	//优化一下，只对前k个排序</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="41数据流中的中位数（困难）-没做————————"><a href="#41数据流中的中位数（困难）-没做————————" class="headerlink" title="41数据流中的中位数（困难）  没做————————"></a>41数据流中的中位数（困难）  没做————————</h3><h2 id="搜索与回溯算法（中等）-1"><a href="#搜索与回溯算法（中等）-1" class="headerlink" title="搜索与回溯算法（中等）"></a>搜索与回溯算法（中等）</h2><h3 id="55-I-二叉树的深度"><a href="#55-I-二叉树的深度" class="headerlink" title="55 I 二叉树的深度"></a>55 I 二叉树的深度</h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//1递归</span><br><span class="line">var maxDepth = function(root)&#123;</span><br><span class="line">	if(!root) return 0;</span><br><span class="line">	let left = maxDepth(root.left);</span><br><span class="line">	let right = maxDepth(root.right);</span><br><span class="line">	return Math.max(left,right) + 1;</span><br><span class="line">&#125;</span><br><span class="line">//2 bfs+迭代</span><br><span class="line">var maxDepth = function(root:TreeNode | null): number&#123;</span><br><span class="line">	if(!root) return 0;</span><br><span class="line">	let queue = [root];</span><br><span class="line">	let res = 0;</span><br><span class="line">	while(queue.length)&#123;</span><br><span class="line">		let len = queue.length;</span><br><span class="line">		while(len &gt;= 0)&#123;</span><br><span class="line">			let node = queue.shift();</span><br><span class="line">			if(node.left) queue.push(node.left);</span><br><span class="line">			if(node.right) queue.push(node.right);</span><br><span class="line">			len--;</span><br><span class="line">		&#125;</span><br><span class="line">		res++;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">//3 bfs</span><br><span class="line">var maxDepth = function(root)&#123;</span><br><span class="line">	if(!root) return 0;</span><br><span class="line">	let queue = [root];</span><br><span class="line">	let res = 0;</span><br><span class="line">	while(queue.length &gt; 0)&#123;</span><br><span class="line">		let tmp = [];</span><br><span class="line">		for(let i = 0 ; i &lt; queue.length ; i++)&#123;</span><br><span class="line">			if(queue[i].left) tmp.push(queue[i].left);</span><br><span class="line">			if(queue[i].right) tmp.push(queue[i].right);</span><br><span class="line">		&#125;;</span><br><span class="line">		queue = tmp;</span><br><span class="line">		res++;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">//4 dfs+回溯 先序遍历</span><br><span class="line">var maxDepth = function(root)&#123;</span><br><span class="line">	let deep = 0 , max = 0;</span><br><span class="line">	dfs(root);</span><br><span class="line">	return max;</span><br><span class="line">	</span><br><span class="line">	function dfs(root)&#123;</span><br><span class="line">		if(!root) return ;</span><br><span class="line">		deep++;</span><br><span class="line">		if(deep &gt; max) max = deep;</span><br><span class="line">		dfs(root.left);</span><br><span class="line">		dfs(root.right);</span><br><span class="line">		deep--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//5 dfs+递归 后序遍历  和1一样</span><br><span class="line">var maxDepth = function(root)&#123;</span><br><span class="line">	if(!root) return 0;</span><br><span class="line">	return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="55-II-平衡二叉树"><a href="#55-II-平衡二叉树" class="headerlink" title="55 II 平衡二叉树"></a>55 II 平衡二叉树</h3><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//遍历到当前结点的左右子节点，AB为根节点的树的左右子树深度差值不超过一</span><br><span class="line">//recusive函数对二叉树进行深度优先遍历，而getDepth函数则获取树的深度</span><br><span class="line">//recusive函数 退出条件：1 当前结点为null或者当前子节点的左右子节点均为null，说明遍历完成，返回true。2当前节点的左右子树深度相差超过1返回false</span><br><span class="line">var isBalanced = function(root)&#123;</span><br><span class="line">	return recusive(root);</span><br><span class="line">&#125;</span><br><span class="line">var recusive = function(root)&#123;</span><br><span class="line">	if(!root || (!root.left &amp;&amp; !root.right)) return true;</span><br><span class="line">	if(Math.abs( getDepth(root.left) - getDepth(root.right) ) &gt; 1) return false;</span><br><span class="line">	return recusive(root.left) &amp;&amp; recusive(root.right);</span><br><span class="line">&#125;</span><br><span class="line">var getDepth = function(root)&#123;</span><br><span class="line">	if(!root) return 0;</span><br><span class="line">	return Math.max(getDepth(root.left) , getDepth(root.right)) + 1;</span><br><span class="line">&#125;</span><br><span class="line">//第二种形式</span><br><span class="line">var isBalanced = function(root)&#123;</span><br><span class="line">	return judge(root) !== -1;</span><br><span class="line">&#125;</span><br><span class="line">const judge = (root) =&gt; &#123;</span><br><span class="line">	if(!root) return 0;</span><br><span class="line">	let left = judge(root.left);</span><br><span class="line">	if(left === -1) return -1;</span><br><span class="line">	let right = judge(root.right);</span><br><span class="line">	if(right === -1) return -1;</span><br><span class="line">	return Math.abs(left - right) &gt; 1 ? -1 : Math.max(left , right) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="64-求1-2-…-n"><a href="#64-求1-2-…-n" class="headerlink" title="64 求1+2+…+n"></a>64 求1+2+…+n</h3><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//一行		前面的n是作为条件判断的</span><br><span class="line">var sumNums = funciton(n)&#123;</span><br><span class="line">	return n &amp;&amp; n + sumNums(--n);</span><br><span class="line">&#125;</span><br><span class="line">//或者</span><br><span class="line">var sumNums = function(n)&#123;</span><br><span class="line">	return n === 1 || (sumNums(n-1) + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="68I-二叉搜索树的最近公共祖先（二叉搜索树，有序）"><a href="#68I-二叉搜索树的最近公共祖先（二叉搜索树，有序）" class="headerlink" title="68I 二叉搜索树的最近公共祖先（二叉搜索树，有序）"></a>68I 二叉搜索树的最近公共祖先（二叉搜索树，有序）</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">var lowestCommonAncestor = function(root,p,q)&#123;</span><br><span class="line">	if(p.val &lt; root.val &amp;&amp; q.val &lt; root.val) return lowestCommonAncestor(root.left,p,q);</span><br><span class="line">	esle if(p.val &gt; root.val &amp;&amp; q.val &gt; root.val) return lowestCommonAncestor(root.right,p,q);</span><br><span class="line">	else return root;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">var lowestCommonAncestor = function(root,p,q)&#123;</span><br><span class="line">	while(root)&#123;</span><br><span class="line">		//p q 是root两侧子节点说明root就是最近的公共祖先</span><br><span class="line">		if((p.val - root.val) * (q.val - root.val) &lt;= 0) return root;</span><br><span class="line">		//这一步说明p q两个节点都在root同侧。</span><br><span class="line">		else root = p.val &gt; root.val ? root.right : root.left;</span><br><span class="line">	&#125;</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="68-II-二叉树的最近公共祖先（无序值的二叉树）"><a href="#68-II-二叉树的最近公共祖先（无序值的二叉树）" class="headerlink" title="68 II 二叉树的最近公共祖先（无序值的二叉树）"></a>68 II 二叉树的最近公共祖先（无序值的二叉树）</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var lowestCommonAncestor = functino(root,p,q)&#123;</span><br><span class="line">	// 如果树为空，直接返回null</span><br><span class="line">	if(!root) return null;</span><br><span class="line">	// 如果 p和q中有等于 root的，那么它们的最近公共祖先即为root（一个节点也可以是它自己的祖先）</span><br><span class="line">	if(root.val === p || root.val === q) return root;</span><br><span class="line">	 // 递归遍历左子树，只要在左子树中找到了p或q，则先找到谁就返回谁</span><br><span class="line">	const left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">	  // 递归遍历右子树，只要在右子树中找到了p或q，则先找到谁就返回谁</span><br><span class="line">	const right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">	 // 如果在左子树中 p和 q都找不到，则 p和 q一定都在右子树中，右子树中先遍历到的那个就是最近公共祖先（一个节点也可以是它自己的祖先）</span><br><span class="line">	if(!left) return rihgt;</span><br><span class="line">	 // 如果 left不为空，在左子树中有找到节点（p或q），这时候要再判断一下右子树中的情况，如果在右子树中，p和q都找不到，则 p和q一定都在左子树中，左子树中先遍历到的那个就是最近公共祖先（一个节点也可以是它自己的祖先）</span><br><span class="line">    else if(!right) return left;</span><br><span class="line">	//当 left和 right均不为空时，说明 p、q节点分别在 root异侧, 最近公共祖先即为 root</span><br><span class="line">	else return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分治法（中等）"><a href="#分治法（中等）" class="headerlink" title="分治法（中等）"></a>分治法（中等）</h2><h3 id="07重建二叉树"><a href="#07重建二叉树" class="headerlink" title="07重建二叉树"></a>07重建二叉树</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">var buildTree = function(preorder,inorder)&#123;</span><br><span class="line">	if(!preorder.length || !inorder.length) return null;</span><br><span class="line">	const root = inorder.findIndex(item =&gt; item === preorder[0]);</span><br><span class="line">	const left = inorder.slice(0,index);</span><br><span class="line">	const right = inorder.slice(index + 1);</span><br><span class="line">	return &#123;</span><br><span class="line">		val: preorder[0];</span><br><span class="line">		left: buildTree(preorder.slice(1,index+1),left);</span><br><span class="line">		right:buildTree(preorder.slice(index + 1),right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//2</span><br><span class="line">var buildTree = function(preorder , inorder)&#123;</span><br><span class="line">	if(!preorder.length || !inorder.length) return null;</span><br><span class="line">	const root = TreeNode(preorder[0]);</span><br><span class="line">	let rootIndex = inorder.findIndex(item =&gt; item === preorder[0]);</span><br><span class="line">	if(rootIndex === -1) return null;</span><br><span class="line">	preorder.shift();</span><br><span class="line">	root.left = buildTree(preorder,inorder(0,rootIndex));</span><br><span class="line">	root.right = buildTree(preorder,inorder(rootIndex + 1));</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br><span class="line">//3</span><br><span class="line">var buildTree = function(preorder,inorder)&#123;</span><br><span class="line">	// 递归返回条件</span><br><span class="line">	if(!preorder.length || !inorder.length) return nulll;</span><br><span class="line">	// 先序遍历的首元素为根结点，创建节点</span><br><span class="line">	const root = new TreeNode(preorder[0]);</span><br><span class="line">	const rootInIndex = inorder.indexOf(preorder[0]);</span><br><span class="line">	 // 用If语句剪枝，减少递归层数（因为创建root时，left right 默认设置为null了，因为不必再设置）</span><br><span class="line">    // 设置左右子节点，递归</span><br><span class="line">	if(rootIndex != 0) root.left = buildTree(preorder.slice(1,1+rootInIndex),inorder.slice(0,rootInIndex));</span><br><span class="line">	if(rootIndex != preorder.length - 1) root.right = buildTree(preorder.slice(1+rootInIndex),inorder.slice(rootInIndex + 1));</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16 数值的整数次方"></a>16 数值的整数次方</h3><p>实现 <a target="_blank" rel="noopener" href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var myPow = function(x,n)&#123;</span><br><span class="line">	if(x === 0) return 0;</span><br><span class="line">	if(n === 0) return 1;</span><br><span class="line">	if(n &lt; 0)&#123;</span><br><span class="line">		x = 1 / x;</span><br><span class="line">		n = -n;</span><br><span class="line">	&#125;</span><br><span class="line">	let result = 1;</span><br><span class="line">	while(n &gt; 0)&#123;</span><br><span class="line">		if(n &amp; 1 === 1)&#123;</span><br><span class="line">			return *= x</span><br><span class="line">		&#125;</span><br><span class="line">		x *= x;</span><br><span class="line">		n &gt;&gt;&gt;= 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33二叉搜索树的后序遍历"><a href="#33二叉搜索树的后序遍历" class="headerlink" title="33二叉搜索树的后序遍历"></a>33二叉搜索树的后序遍历</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//二叉搜索树特点是右子树值永远大于左子树</span><br><span class="line">后序遍历：左子树 -&gt; 右子树 -&gt; 根</span><br><span class="line">取出左子树，取出右子树，判断右子树 和 根相比最小值是不是根值，否，则返回false</span><br><span class="line">递归左子树和右子树，直到树中值元素&lt;=2 返回true;</span><br><span class="line">举例[1,6,3,2,5]，分为左子树[1],右子树[6,3,2],根[5], Math.min(6,3,2,5) !== 5, return false</span><br><span class="line">时间空间复杂度： O(nlogn), O(n)</span><br><span class="line">var verifyPostOrder = function(postorder)&#123;</span><br><span class="line">	if(postorder.length &lt;= 2) return true;</span><br><span class="line">	const root = postorder[postorder.length -1];</span><br><span class="line">	const idx = postorder.findIndex( (item) =&gt; item &gt; root);</span><br><span class="line">	const left = postorder.slice(0,idx);</span><br><span class="line">	const right = postorder.slice(idx,-1);</span><br><span class="line">	if(Math.min(root,...right) !== root) return false;</span><br><span class="line">	return verifyPostorder(left) &amp;&amp; verifyPostorder(right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="15二进制中1的个数"><a href="#15二进制中1的个数" class="headerlink" title="15二进制中1的个数"></a>15二进制中1的个数</h3><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//按位与&amp;,对应位数都为1则为1；,循环的条件：只要存在有1的情况n就不会为0；,退出循环时，说明n==0；,没循环一次count++；</span><br><span class="line">var hammingWeight = function(n)&#123;</span><br><span class="line">	let count = 0;</span><br><span class="line">	while(n != 0)&#123;</span><br><span class="line">		n = n &amp; (n - 1);</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	return count;</span><br><span class="line">&#125;</span><br><span class="line">// toString()方法中传入的数字就是可以根据所传递的参数把数值转换为对应进制的数字字符串。</span><br><span class="line">var hammingWeight = function(n)&#123;</span><br><span class="line">	return n.toString(2).split(&quot;1&quot;).length - 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65 不用加减乘除做加法"></a>65 不用加减乘除做加法</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">var add = function(a,b)&#123;</span><br><span class="line">	while(b != 0)&#123;</span><br><span class="line">		var c = (a ^ b)</span><br><span class="line">		b = ((a &amp; b) &lt;&lt; 1)</span><br><span class="line">		a = c</span><br><span class="line">	&#125;</span><br><span class="line">	return a</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">var add = function(a,b)&#123;</span><br><span class="line">	if((a &amp; b) === 0) return a | b;</span><br><span class="line">	let x = a ^ b,y = (a &amp; b) &lt;&lt; 1;</span><br><span class="line">	return add(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="56-I-数组中数字出现的次数——————"><a href="#56-I-数组中数字出现的次数——————" class="headerlink" title="56 I 数组中数字出现的次数——————"></a>56 I 数组中数字出现的次数——————</h3><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="56-II-数组中数字出现的次数——————"><a href="#56-II-数组中数字出现的次数——————" class="headerlink" title="56 II 数组中数字出现的次数——————"></a>56 II 数组中数字出现的次数——————</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数学（简单）"><a href="#数学（简单）" class="headerlink" title="数学（简单）"></a>数学（简单）</h2><h3 id="39数组中出现次数超过一半的数字"><a href="#39数组中出现次数超过一半的数字" class="headerlink" title="39数组中出现次数超过一半的数字"></a>39数组中出现次数超过一半的数字</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//方法1：快排后，返回nums[n/2]</span><br><span class="line">var majorityElement = function(nums)&#123;</span><br><span class="line">	if(!nums || !nums.length) return -1;</span><br><span class="line">	quickSort(nums,0,nums.length - 1);</span><br><span class="line">	return nums[Math.floor(nums.length / 2)];</span><br><span class="line">&#125;</span><br><span class="line">function quickSort(nums,lo,hi)&#123;</span><br><span class="line">	if(lo &gt;= hi) return ;</span><br><span class="line">	let i = partition(nums,lo,hi);</span><br><span class="line">	quickSort(nums,lo,hi);</span><br><span class="line">	quickSort(nums,i + 1,hi);</span><br><span class="line">&#125;</span><br><span class="line">function partition(nums,lo,hi)&#123;</span><br><span class="line">	let pivot = nums[lo];</span><br><span class="line">	let i = lo + 1,j = hi;</span><br><span class="line">	while(i &lt;= j)&#123;</span><br><span class="line">		while(nums[i] &lt; pivot &amp;&amp; i &lt;= j) i++;</span><br><span class="line">		while(nums[j] &gt; pivot &amp;&amp; i &lt;= j) j--;</span><br><span class="line">		if(i &lt; j)&#123;</span><br><span class="line">		 let tmp = nums[i];</span><br><span class="line">		 nums[i] = nums[j];</span><br><span class="line">		 nums[j] =  tmpm;</span><br><span class="line">		 i++;</span><br><span class="line">		 j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//方法2：遍历数组将每个元素出现的次数存到map中，遍历map找到次数大于nums.length / 2的</span><br><span class="line">var majorityElement = function(nums)&#123;</span><br><span class="line">	let map = new Map();</span><br><span class="line">	for(let i = 0; i &lt; nums.length ; i++)&#123;</span><br><span class="line">		let n = nums[i];</span><br><span class="line">		if(!map.has(n)) map.set(n,1)</span><br><span class="line">		else map.set(n,map.get(n) + 1)</span><br><span class="line">		</span><br><span class="line">		for([key,value] of map)&#123;</span><br><span class="line">			if(value &gt; nums.legnth &gt;&gt;1) return key;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66. 构建乘积数组"></a>66. 构建乘积数组</h3><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]&#x3D;A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">var constructArr = function(a)&#123;</span><br><span class="line">	let n = a.length</span><br><span class="line">	if(!n) return []		//特殊情况：非空判定</span><br><span class="line">	let result = new Array(n).fill(1)	//结果中的任一元素 = 左边元素乘积 * 右边元素乘积</span><br><span class="line">	let rightAccu = 1</span><br><span class="line">	for(let i = 1 ; i &lt; n ; i++)&#123;		//构建左边的乘积放在数组中</span><br><span class="line">		result[i] = result[i-1] * a[i-1]</span><br><span class="line">	&#125;</span><br><span class="line">	for(let i = n - 2 ; i &gt;=0 ; i--)&#123;	</span><br><span class="line">		rightAccu *= a[i + 1]		//构建右边的乘积</span><br><span class="line">		result[i] *= rightAccu		//乘以左边的乘积就是结果</span><br><span class="line">	&#125; </span><br><span class="line">	return result</span><br><span class="line">&#125;</span><br><span class="line">//暴力</span><br><span class="line">var constructArr = fucntion(a)&#123;</span><br><span class="line">	const res = []</span><br><span class="line">	let n = a.length</span><br><span class="line">	for(let i = 0 ; i &lt; n ; i++)&#123;</span><br><span class="line">		let temp = 1</span><br><span class="line">		for(let j = 0; j &lt; n ;j++)&#123;</span><br><span class="line">			if(i != j)&#123;</span><br><span class="line">				temp *= a[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		res.push(temp)</span><br><span class="line">	&#125;</span><br><span class="line">	return res</span><br><span class="line">&#125;</span><br><span class="line">//动态规划</span><br><span class="line">var constructArr = function(a)&#123;</span><br><span class="line">	if(a == null || !a.length) return a 		//边界条件判断</span><br><span class="line">	let length = a.length</span><br><span class="line">	let resLeft = []		//每个元素左边的乘积</span><br><span class="line">	let resRight = []		//每个元素右边的乘积</span><br><span class="line">	resLeft[0] = 1			//base case</span><br><span class="line">	resRight[length - 1] = 1</span><br><span class="line">	for(let i = 1; i &lt; length ; i++)&#123;</span><br><span class="line">		// 状态转移方程 resLeft[i]表示 当前元素左边的所有元素乘积（不包含当前元素）</span><br><span class="line">        // resLeft[i - 1]不包括a[i - 1] 乘以✖️a[i-1]就表示当前 resLeft[i]</span><br><span class="line">        resLeft[i] = resLeft[i - 1] * a[i -1]</span><br><span class="line">	&#125;</span><br><span class="line">	   for (let  i = length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        resRight[i] = resRight[i + 1] * a[i + 1];</span><br><span class="line">    &#125;</span><br><span class="line">    //左边乘以右边就是我们要求的结果</span><br><span class="line">    let  res =  [];</span><br><span class="line">    for (let  i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        res[i] = resLeft[i] * resRight[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数学（中等）"><a href="#数学（中等）" class="headerlink" title="数学（中等）"></a>数学（中等）</h2><h3 id="14-I-剪绳子"><a href="#14-I-剪绳子" class="headerlink" title="14-I 剪绳子"></a>14-I 剪绳子</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">var cuttingRope = function(n)&#123;</span><br><span class="line">	//s的初始值为n=2的情况</span><br><span class="line">	var s = [1,1]		</span><br><span class="line">	var len = s.length</span><br><span class="line">	//从3开始</span><br><span class="line">	for(var i = 3 ; i &lt;= n ; i++)&#123;		</span><br><span class="line">         //每次都更改最前面的那个因子</span><br><span class="line">		s[0]++</span><br><span class="line">		//如果因子等于4就要把它分成两个值为2的因子</span><br><span class="line">		if(s[0] == 4)&#123;</span><br><span class="line">			s[0] = 2</span><br><span class="line">			s[++len] = 2</span><br><span class="line">		&#125;</span><br><span class="line">		//因为每次更改最前面的，所以要确保最前面是6最小的</span><br><span class="line">		s.sort((a,b) =&gt; a - b)</span><br><span class="line">	&#125;</span><br><span class="line">	//用for循环把所有的因子乘起来就是n的最大值</span><br><span class="line">	for(var i = 1 ; i &lt; len ; i++)&#123;</span><br><span class="line">		s[i] *= s[i-1]</span><br><span class="line">		return s[len - 1]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//动态规划</span><br><span class="line">var cuttingRope = function(n)&#123;</span><br><span class="line">	let i,j,dp = new Array(n+1).fill(0),nowBigger</span><br><span class="line">	dp[2] = 1</span><br><span class="line">	for(i = 2 ; i &lt;= n ; i++)&#123;</span><br><span class="line">		for(j = 1 ; j &lt; i ; j++)&#123;</span><br><span class="line">			nowBigger = Math.max(j * (i - j),j * dp[i - j])</span><br><span class="line">			dp[i] = Math.max(dp[i],nowBigger)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="57-II和为s的连续正数序列"><a href="#57-II和为s的连续正数序列" class="headerlink" title="57-II和为s的连续正数序列"></a>57-II和为s的连续正数序列</h3><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var findCotinuousSequence = function(target)&#123;</span><br><span class="line">	let left = 1 ,right = 0,sum = 0,ans = []</span><br><span class="line">	//最大不超过target的一半</span><br><span class="line">	while(right &lt;= Math.round(target / 2))&#123;</span><br><span class="line">		if(sum === target)&#123;</span><br><span class="line">			//sum等于目标</span><br><span class="line">			let temp = []</span><br><span class="line">			for(let i = left ; i &lt;= right ; i++)&#123;</span><br><span class="line">				temp.push(i)</span><br><span class="line">			&#125;</span><br><span class="line">			if(temp.length)&#123;</span><br><span class="line">				ans.push(temp)</span><br><span class="line">			&#125;</span><br><span class="line">			sum -= left</span><br><span class="line">			left++</span><br><span class="line">		&#125;</span><br><span class="line">		//sum大于目标数，左边-</span><br><span class="line">		while(sum &gt; target)&#123;</span><br><span class="line">			sum -= left		// *** -= 和下面left移动的顺序要想清楚***</span><br><span class="line">			left++</span><br><span class="line">		&#125;</span><br><span class="line">		//sum小于目标数，右边+</span><br><span class="line">		while(sum &lt; target)&#123;</span><br><span class="line">			sum += right</span><br><span class="line">			right++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62 圆圈中最后剩下的数字"></a>62 圆圈中最后剩下的数字</h3><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var lastRemaining = function(n,m)&#123;</span><br><span class="line">	let pos = 0</span><br><span class="line">	for(let i = 2 ; i &lt;= n ; i++)&#123;</span><br><span class="line">		pos = (pos + m) % i</span><br><span class="line">	&#125;</span><br><span class="line">	return pos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="模拟（中等）"><a href="#模拟（中等）" class="headerlink" title="模拟（中等）"></a>模拟（中等）</h1><h3 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29 顺时针打印矩阵"></a>29 顺时针打印矩阵</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var spiralOrder = function(matrix)&#123;</span><br><span class="line">	if(matrix.length == 0) return []</span><br><span class="line">	const res = []</span><br><span class="line">	let top = 0</span><br><span class="line">	let bottom = matrix.length - 1</span><br><span class="line">	let left = 0</span><br><span class="line">	let right = matrix[0].length - 1</span><br><span class="line">	</span><br><span class="line">	while(top &lt; right &amp;&amp; left &lt; right)&#123;</span><br><span class="line">		for(let i = left; i &lt; right ; i++) res.push(matrix[top][i])</span><br><span class="line">		for(let i = top ; i &lt; bottom ; i++) res.push(matrix[i][right])</span><br><span class="line">		for(let i = right ; i &gt; left ; i--) res.push(matrix[bottom][i])</span><br><span class="line">		for(let i = bottom ; i &gt; top ; i--) res.push(mtrix[i][left])</span><br><span class="line">		right--</span><br><span class="line">		left++</span><br><span class="line">		top--</span><br><span class="line">		bottom++</span><br><span class="line">	&#125;</span><br><span class="line">	if(top == bottom)&#123;</span><br><span class="line">		for(let i = left ; i &lt;= right ; i++)&#123;</span><br><span class="line">			res.push(matrix[top][i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else if(left == right)&#123;</span><br><span class="line">		for(let i = top ; i &lt;= bottom ; i++)&#123;</span><br><span class="line">			res.push(matrix[i][left])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="剑指offerII"><a href="#剑指offerII" class="headerlink" title="剑指offerII"></a>剑指offerII</h1><h3 id="001-整数除法"><a href="#001-整数除法" class="headerlink" title="001 整数除法"></a>001 整数除法</h3><p>给定两个整数 <code>a</code> 和 <code>b</code> ，求它们的除法的商 <code>a/b</code> ，要求不得使用乘号 <code>&#39;*&#39;</code>、除号 <code>&#39;/&#39;</code> 以及求余符号 <code>&#39;%&#39;</code> 。</p>
<p>注意：</p>
<p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) &#x3D; 8 以及 truncate(-2.7335) &#x3D; -2<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31−1]。本题中，如果除法结果溢出，则返回 2^31 − 1</p>
<p>先把特殊情况排除，然后最先判断<strong>正负号</strong>，然后把负负情况改为正。创建<strong>结果</strong>。 用减法代替除法进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var divide = function(a,b)&#123;</span><br><span class="line">	//排除特殊情况</span><br><span class="line">	if(a === -Math.pow(2,31) &amp; b === -1) return (Math.pow(2,31) - 1)</span><br><span class="line">	//记录正负号</span><br><span class="line">	let p = 0</span><br><span class="line">	if(a &lt; 0 &amp; b &lt; 0) &#123; p = 0&#125;</span><br><span class="line">	else if(a &gt; 0 &amp; b &gt; 0) &#123; p = 0&#125;</span><br><span class="line">	else p = 1</span><br><span class="line">	</span><br><span class="line">	//处理负数，最后进行添加负号</span><br><span class="line">	if(a &lt; 0)  a = -a</span><br><span class="line">	if(b &lt; 0)  b = -b</span><br><span class="line">	</span><br><span class="line">	let result = 0</span><br><span class="line">	//主要处理</span><br><span class="line">	while(a &gt;= b)&#123;</span><br><span class="line">		a -= b</span><br><span class="line">		result++</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if(p === 1)&#123;result = -result&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-04-30</span><span class="leancloud_visitors"></span><span>About 10951 words, 36 min 30 sec  read</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2023/04/30/Leetcode剑指offerI/,Lemonadeccc,剑指offerI,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2023/04/30/rust%E5%88%9D%E5%AD%A6/" title="rust初学">Previous</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>